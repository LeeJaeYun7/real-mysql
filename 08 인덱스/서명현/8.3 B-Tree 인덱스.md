# 3. B-Tree 인덱스

데이터베이스의 인덱싱 알고리즘 중 가장 일반적으로 사용되고 있다. B-Tree에는 여러 변형된 형태인 B+Tree, B*Tree 등이 있다.
여기서 B는 Balanced를 의미한다. 항상 균형잡힌 트리 구조를 유지하고 있고, 데이터를 탐색하는데, 시간 복잡도가 O(logN)을 보장한다.

데이터의 양이 많아져도 트리 깊이가 매우 느리게 성장하기 때문에 검색하는데 걸리는 시간이 잘 늘어나지 않는다. 이것을 대수확장성이라고도 한다.

## 1) B-Tree 구조

B-Tree는 최상위에 하나의 '루트 노드'가 존재하고, 가장 마지막 깊이의 노드를 '리프 노드'라고 한다. 루트 노드와 리프 노드를 제외한 나머지 노드를 '브랜치 노드'라고 한다.
데이터베이스는 인덱스와 실제 데이터가 저장된 데이터는 따로 관리하는데, 인덱스의 리프 노드는 항상 실제 데이터 레코의 주솟값을 가지고 있다.

![스크린샷 2023-12-08 190846](https://github.com/LeeJaeYun7/real-mysql/assets/62706048/5353b06b-9278-47ce-9705-6180b3b2f9bb)

인덱스는 테이블의 키 컬럼만 가지고 있고, 실제 데이터는 따로 저장되어 있다.
그래서, 인덱스의 리프 노드는 항상 실제 데이터 레코드의 주솟값을 가지고 데이터 파일에서 해당 레코드를 찾아간다.

여기서 두 스토리지 엔진의 인덱스에서 차이점이 나온다.
세컨더리 인덱스를 통해 데이터 파일의 레코드를 찾아가는 방식이 다르다.
MyISAM은 인덱스의 리프 노드가 실제 데이터 레코드를 가리키고 있지만, InnoDB는 인덱스의 리프 노드가 실제 데이터 레코드를 가리키고 있지 않다.
InnoDB는 리프 노드의 인덱스에 저장된 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색하고, 프라이머리 키 이넥스의 리프 페이지에 저장되어 있는 레코드를 읽는다.

<사진>

이것은 성능이 떨어져 보이지만, 사실 각각 장단점이 있다. 클러스터링 인덱스 설명할 때 언급하겠다.

## 2) B-Tree 인덱스 키 추가, 삭제

B-Tree 인덱스는 데이터를 추가하거나 삭제할 때, B-Tree 상의 적절한 위치를 검색하고, 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.
이러한 작업으로 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 드는 것으로 알려졌다.

MyISAM 스토리지 엔진을 사용하는 테이블에서는 데이터 삽입 시에, 즉시 새로운 키 값을 B-Tree에 추가한다. 
하지만, InnoDB 스토리지 엔진을 사용하는 테이블에서는 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다. 하지만 프라이머리 키나 유니크 키는 중복 체크가 필요하기 때문에 즉시 추가하거나 삭제한다.

### B-Tree 인덱스 키 변경

B-Tree 인덱스는 키 값을 변경할 때, 기존의 키 값을 삭제하고, 새로운 키 값을 추가하는 방식으로 동작한다. 단순히 값만 변경하는 것은 불가하다. 이 작업 모두 체인지 버퍼를 활용해 지연 처리될 수 있다.

### B-Tree 인덱스 키 검색

데이터 변경에 대한 추가 비용을 감당하면서 인덱스를 구축하는 이유는 빠른 검색을 위해서이다. 

특히, InnoDB 스토리지 엔진에서의 인덱스는 더 특별하다. InnoDB 테이블에서 지원하는 레코드 잠금이나 next key lock 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있다.

### B-Tree 인덱스의 깊이

B-Tree 인덱스의 깊이는 상당히 중요하지만 직접 제어할 방법은 없다. 인덱스 키 값의 크기가 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그 때문에 B-Tree의 깊이가 더 깊어져서 디스크 읽기가 더 많이 필요하게 된다.
그래서 인덱스 키 값의 크기는 가능한 작게 만드는 것이 좋다. 실제로 아무리 대용량 데이터베이스라도 B-Tree 깊이가 5단계 이상까지 깊어지는 경우는 흔치 않다.

인덱스 키 값을 줄이려면 인덱스 기 값의 길이를 줄이는 것도 하나의 방법이다. 다른 방법이 있는지..?

## 3) B-Tree 인덱스를 통한 데이터 읽기

MySQL이 인덱스를 이용하는 대표적인 방법 3가지를 살펴보자.

### 인덱스 레인지 스캔

인덱스의 접근 방법 중 가장 대표적인 접근 방식이다. 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다. 루트 노드에서부터 시작해서 리프 노드까지 탐색하면서 해당 범위의 데이터를 찾아가는 방식이다.

나머지 두 개의 접근방식보다 빠른 방법이다.

### 인덱스 풀 스캔

인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만, 처음부터 끝까지 모두 읽는 방식이다. 인덱스를 읽으면서 데이터를 찾아가는 것이 아니라, 인덱스를 읽으면서 데이터를 읽는다.
인덱스 레인지 스캔보다 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.

continue...
