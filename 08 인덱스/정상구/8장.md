## 8.1 디스크 읽기 방식
### 8.1.1 HDD 와 SSD
- HDD 는 기계식 장치, SSD 는 전자식 장치
- SSD 는 HDD 에 비해 랜덤 I/O 강점
- SSD 는 OLTP 환경에서 더 유리

### 8.1.2 랜덤 I/O 와 순차 I/O
일반적으로 쿼리를 튜닝한다는 것은 랜덤 I/O 를 줄이는 것

>인덱스 레인지 스캔은 데이터 읽기 위해 주로 랜덤 I/O 사용, 풀 테이블 스캔 순차I/O
>레코드가 많을 경우 풀 테이블 스캔 유리, OLAP 환경에 적합

## 8.2 인덱스란?
- 모든 데이터를 검색하려면 오래 걸리므로, 칼럼과 레코드 주소를 키와 값의 쌍으로 삼아 인덱스 생성
- 인덱스 자료구조 SortedList 를 사용하면 R 성능 향상, CUD 성능 저하
- 인덱스는 데이터 관리하는 방식과 중복 값의 허용 여부에 따라 여러가지로 나뉨

### 인덱스 분류
- 역할
	- `Primary Key` NOT NULL, 중복 허용 X
	- `Secondary Key` 유니크 인덱스는 프라이머리 키 비슷 **대체키** 라고도 불림
- 데이터 저장 방식
	- `B-Tree` 칼럼값 변형하지 않고 원래 값 이용해 인덱싱하는 알고리즘 ( 위치 기반 검색 R-Tree 는 B-Tree 응용)
	- `Hash` 인덱스 알고리즘은 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘, 매우 빠른 검색 But 전방 일치 같의 일부 검색 및 범위 검색 사용 못함
- 데이터 중복 허용 여부
	- Unique 동등 조건 옵티마이저
	- Non Unique
- 기능
	- 전문 검색용
	- 공간 검색용

## 8.3 B-Tree 인덱스
B-Tree 는 Balanced Tree 로, 칼럼 값 변형시키지 않고, 구조체 내에서 항상 정렬된 상태 유지

### 8.3.1 구조 및 특성
- 루트 노드
- 브랜치 노드
- 리프 노드 > 항상 실제 데이터 레코드를 찾아가기 위한 주소값 가짐
인덱스의 키 값은 모두 정렬된 상태, 데이터 파일 레코드는 정렬 X 임의의 순서로 저장
**InnoDB 테이블에서 레코드는 클러스터 되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.**

InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 프라이머리 키를 저장하고 있는 B-Tree 를 다시 한번 검색해야 한다.

![](Pasted%20image%2020231205101531.png)

![](Pasted%20image%2020231205101802.png)

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제
#### 8.3.2.1 인덱스 키 추가
B-Tree 에 키 추가시 레코드 키 값과 레코드 주소 정보 리프 노드에 저장, 리프 노드 초과시 분리해야 되는데 상위 브랜치 노드까지 전파하므로 쓰기 작업 비용 많이 든다.
- 칼럼 수, 칼럼의 크기, 인덱스 칼럼의 특성 고려
- 비용 계산 레코드 추카 작업 비용 1 기준 인덱스 키 추가 1.5, 인덱스 N개 있다면 N * 1.5 비용 증가
	- 작업 지연 가능, 4.2.10 체인지 버퍼 참조

#### 8.3.2.2 인덱스 키 삭제
리프 노드 찾아 삭제 마킹

#### 8.3.2.3 인덱스 키 변경
변경은 불가능, 키 값 삭제한 후에 다시 새로운 키 추가하는 형태

#### 8.3.2.4 인덱스 키 검색
B-Tree 인덱스 이용한 검색 100% 일치 또는 전방 일치 경우만 가능, 키 값을 변형시키면 인덱스 사용 못하므로 쿼리 튜닝시 유의 사항

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
- 칼럼의 크기
- 레코드의 건수
- 유니크한 인덱스 키 값의 개수

#### 8.3.3.1 인덱스 키 값의 크기
`innodb_page_size` 시스템 변수, 기본값 16KB

위의 기준이 영향을 얼마나 미치는지 계산
인덱스 키 16바이트, 자식 노드주소 12바이트 구성 가정
하나의 인덱스 페이지에 키 저장 가능 갯수 > 16 * 1024/(16+12) = 585
키 값 두배 증가시 32바이트 > 16 * 1024 / (32+12) = 372

이는 읽어야 할 페이지 수가 증가하므로, I/O 늘어남

#### 8.3.3.2 B-Tree 깊이
인덱스 B-Tree 깊이 3 인경우 최대 몇 개 키 값?
키값 16바이트 585 * 585 * 585 최대 2억 / 키값 32바이트 372 * 372 * 372 5천만
인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋음

#### 8.3.3.3 선택도(기수성)
모든 인덱스 키 값 가운데 유니크한 값의 수
카디널리티가 높을수록 인덱스에 적합

#### 8.3.3.4 읽어야 하는 레코드의 건수
인덱스를 통해 레코드를 읽는 건 비용이 많이듬, 풀스캔할지 인덱스를 이용할지 비용 계산 필요

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기
#### 8.3.4.1 인덱스 레인지 스캔
인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
1. 인덱스 탐색
2. 탐색된 위치부터 필요한만큼 인덱스 읽기, 인덱스 스캔
3. 인덱스 키와 레코드 주소 이용해 페이지 가져와서 레코드 읽음 (레코드당 랜덤 I/O 발생)
커버링 인덱스 이용하면 3번과정 불필요 (디스크 레코드 읽지 않아도됨)

#### 8.3.4.2 인덱스 풀 스캔
쿼리 조건절 사용된 칼럼 인덱스의 첫번째 칼럼이 아닌 경우 인덱스 풀스캔

>인덱스를 사용한다 라는 표현은 인덱스 레인지 스캔이나 루스 인덱스 스캔 방식을 사용하는것을 의미
>인덱스 풀스캔은 효율적으로 사용 X

#### 8.3.4.3 루스 인덱스 스캔
오라클 인덱스 스킵 스캔과 유사, 루스 <-> 타이트 (위의 스캔방식은 타이트)
group by 또는 집합 함수 중 MAX, MIN 함수 최적화 경우 사용

#### 8.3.4.4 인덱스 스킵 스캔
인덱스는 값이 정렬되어 있고, 이를 구성하는 칼럼의 순서가 중요
아래 쿼리 중 첫번째 쿼리는 본래 인덱스 사용 안됬으나, 이를 인덱스 스킵 스캔 최적화 기능이 8.0부터 추가

```
SELECT * FROM employees WHERE birth_date >= ''

SELECT * FROM employees WHERE gender = 'M' AND birth_date >= ''
```

단점
- WHERE 조건절 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야함
- 커버링 인덱스아니면, 테이블 풀스캔할수잇음

### 8.3.5 다중 칼럼 인덱스
인덱스 내에서 칼럼의 위치 중요

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
#### 8.3.6.1 인덱스의 정렬
5.7 버전까지 정렬 순서 혼합 불가능, 8 부터 혼합 가능
인덱스 스캔 방향은 옵티마이저가 결정

InnoDB 역순스캔 정순에 비해 느리다

- 페이지 잠금이 정순에 적합한 구조
- 페이지 내 인덱스 레코드가 단방향으로만 연결된 구조

### 8.3.7 B-Tree 인덱스의 가용성과 효용성
인덱스 사용 가능한 경우 탐색

8.3.7.1 비교 조건의 종류와 효율성

```
SELECT * FROM dept_emp
WHERE dept_no='d002' AND emp_no >= 10114;

케이스 A: INDEX(dept_no, emp_no)
케이스 B: INDEX(emp_no, dept_no)
```

- 작업 범위 결정 조건
- 필터링 조건 또는 체크 조건

#### 8.3.7.3 가용성과 효율성 판단
작업 범위 결정 조건 사용 불가 케이스
- NOT-EQUAL 비교
- LIKE '%??'
- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
- NOT-DETERMINISTIC 속성 스토어드 함수가 비교 조건에 사용된 경우
- 데이터 타입이 서로 다른 비교
- 문자열 데이터 타입의 콜레이션이 다른 경우

## 8.6 함수 기반 인덱스
- 가상 칼럼을 이용한 인덱스
- 함수를 이용한 인덱스

## 8.8 클러스터링 인덱스
### 8.8.1 클러스터링 인덱스
- 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용
- 프라이머리 키 값이 비슷한 레코들 끼리 묶어서 저장하는 것을 클러스터링 인덱스

1. PK 존재하면 클러스터링 키로 선택
2. NOT NULL 옵션 유니크 인덱스 중 첫번째 인덱스 클러스터링 키 선택
3. 내부적으로 유니크한 값을 가지도록 증가되는 컬럼 생성, 클러스터링 키로 선택

### 8.8.2 세컨더리 인덱스에 미치는 영향
MyISAM, InnoDB 레코드 검색 차이

### 8.8.3 클러스터링 인덱스의 장점과 단점
장점
- PK로 검색시 처리 성능 빠름
- 세컨더리 인덱스가 PK 가지고 있어, 인덱스만으로 처리될수있는 경우 많음(커버링 인덱스)

단점
- 클러스터링 키값 커지면 전체적으로 인덱스 크기 커짐
- 세컨더리 인덱스 통해 검색할때 프라이머리 키로 다시 한번 검색함으로 성능 느림
- INSERT 시 PK 에 의해 레코드 저장 위치 결정 되서 성능 느림
- PK 변경시 DELETE INSERT 작업으로 성능 느림

읽기 비율과 성능이 중요한 OLTP 환경에서 사용 적합

### 8.8.4 클러스터링 테이블 사용 시 주의사항

#### 8.8.4.1 클러스터링 인덱스 키의 크기

#### 8.8.4.2 프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 칼럼으로 생성
칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표하면 좋음

#### 8.8.4.3 프라이머리 키는 반드시 명시할 것
PK 반드시 생성할것, 무의미한 AUTO_INCREMENT 칼럼이라도 이용

#### 8.8.4.4 AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우
복합 PK 만드는 경우, 프라이머리 키를 대체하기 위해 인위적으로 추가된 PK를 인조 식별자(Surrogate key) 라고함

## 8.9 인덱스
유니크는 인덱스라기 보다 제약조건에 가까움
NULL 저장 가능, NULL 은 특정 값이 아니므로 2개 이상 저장

### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스 비교
#### 8.9.1.1 인덱스 읽기
인덱스 성능 차이는 없음, 단지 읽어야 할 레코드 많아 오래걸림

#### 8.9.1.2 인덱스 쓰기
유니크 인덱스는 쓰기 작업시 중복된 값 확인 과정이 한단계 더 있어 느림
중복값 체크시 읽기잠금, 쓰기시 쓰기잠금 사용할때 데드락 자주 발생
중복체크 때문에 작업 자체 버퍼링 불가

### 8.9.2 유니크 인덱스 사용 시 주의사항
유일성이 꼭 보장돼야 하는 칼럼에 대해서는 유니크 인덱스를 생성

## 8.10 외래키
- 왜리키는 InnoDB 만 지원
- 외래키 제약 설정시 자동으로 연관 테이블 칼럼에 인덱스 생성

외래키 두가지 특징
- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않음