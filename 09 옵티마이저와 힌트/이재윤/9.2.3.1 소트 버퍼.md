

```

Summary

1) MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트 버퍼(Sort buffer)라고 합니다.
-> 소트 버퍼는 정렬이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만,
   최대 사용 가능한 소트 버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다
-> 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다.


2) 여기까지는 아주 이상적인 부분만 이야기했는데, 지금부터 정렬이 왜 문제가 되는지 살펴보자.
-> 정렬해야 할 레코드가 아주 소량이어서 메모리에 할당된 소트 버퍼만으로 정렬할 수 있다면,
   아주 빠르게 정렬이 처리될 것이다
-> 하지만 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 어떨까?
-> 이 때, MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용한다.

3) 메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록해 둔다.
-> 그리고 다음 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시 저장한다.
-> 이처럼 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 한다.
-> 이 병합 작업을 멀티 머지(Multi-Merge)라고 표현하며,
   수행된 멀티 머지 횟수는 Sort_merge_passes라는 상태 변수(SHOW STATUS VARIABLES 명령 참조)에 누적해서 집계된다.

4) 이 작업들이 모두 디스크의 쓰기와 읽기를 유발하며, 레코드 건수가 많을수록 이 반복 작업의 횟수가 많아진다
-> 소트 버퍼를 크게 설정하면 디스크를 사용하지 않아서 더 빨라질 것으로 생각할 수도 있지만,
   실제 벤치마크 결과로는 큰 차이를 보이진 않았다.
-> 그림 9.1은 MySQL의 소트 버퍼 크기를 확장해가면서 다음 쿼리를 실행했을 때, 소요되는 시간을 측정한 것이다
-> 이 쿼리는 salaries 테이블의 2844047건 레코드를 모두 읽어서 정렬하는데,
   to_date 칼럼에 인덱스가 없기 때문에 쿼리 처리 시에 정렬 작업이 필요한 쿼리다
-> 마지막의 LIMIT 절은 일부러 화면에 표시되는 내용을 최소화하기 위해서 추가해둔 옵션이다.

Insight
- 소트 버퍼의 기능

Application
- 소트 버퍼 분석해보기 
















```
