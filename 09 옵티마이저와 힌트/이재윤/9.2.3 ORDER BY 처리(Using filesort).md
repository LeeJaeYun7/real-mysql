


```

Summary

1) 레코드 1~2건을 가져오는 쿼리를 제외하면 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다
-> 데이터 웨어하우스처럼 대량의 데이터를 조회해서 일괄 처리하는 기능이 아니라면 아마도 레코드 정렬 요건은
   대부분의 조회 쿼리에 포함돼 있을 것이다
-> 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 "Filesort"라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.


(1) 인덱스 이용
- 장점
-> INSERT, UPDATE, DELETE 쿼리가 실행될 때, 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다
- 단점
-> INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다
-> 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다

(2) Filesort 이용
- 장점
-> 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다
-> 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다
- 단점
-> 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다

- 물론 레코드를 정렬하기 위해 항상 Filesort라는 정렬 작업을 거쳐야 하는 것은 아니다
-> 이미 인덱스를 이용한 정렬은 8.3.6절 'B-Tree 인덱스의 정렬 및 스캔 방향'에서 한 번 살펴봤다
-> 하지만 다음과 같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능하다.

(1) 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
(2) GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
(3) UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
(4) 랜덤하게 결과 레코드를 가져와야 하는 경우

- MySQL 서버에서 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra 칼럼에 "Using filesort" 메시지가 표시되는지
  여부로 판단할 수 있다
-> 여기서는 MySQL의 정렬이 어떻게 처리되는지 살펴보고자 한다
-> MySQL의 정렬 특성을 이해하면 쿼리를 튜닝할 때 어떻게 하면 조금이라도 더 빠른 쿼리가 될지 쉽게 판단할 수 있을 것이다.


Insight
- Filesort의 활용

Application
- MySQL 쿼리 튜닝하기 














```
