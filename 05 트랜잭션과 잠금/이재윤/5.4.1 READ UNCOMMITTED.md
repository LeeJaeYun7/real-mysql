


```
Summary

1) READ UNCOMMITTED 격리 수준에서는 그림 5.3과 같이 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이
   다른 트랜잭션에서 보인다.
-> 그림 5.3은 다른 트랜잭션이 사용자 B가 실행하는 SELECT 쿼리의 결과에 어떤 영향을 미치는지를 보여주는 예제다.


2) 그림 5.3에서 사용자 A는 emp_no가 500000이고, first_name이 "Lara"인 새로운 사원을 INSERT한다.
-> 사용자 B가 변경된 내용을 커밋하기도 전에 사용자B는 emp_no=500000인 사원을 검색하고 있다.
-> 하지만 사용자B는 사용자 A가 INSERT한 사원의 정보를 커밋되지 않은 상태에서도 조회할 수 있다.
-> 그런데 문제는 사용자 A가 처리 도중 알 수 없는 문제가 발생해 INSERT된 내용을 롤백한다고 하더라도
   여전히 사용자 B는 "Lara"가 정상적인 사원이라고 생각하고 계속 처리할 것이라는 점이다.


3) 이처럼 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을
   더티 리드(Dirty Read)라 하고, 더티 리드가 허용되는 격리 수준이 READ UNCOMMITTED다.
-> 더티 리드 현상은 데이터가 나타났다가 사라졌다 하는 현상을 초래하므로, 애플리케이션 개발자와 사용자를 상당히
   혼란스럽게 만들 것이다.
-> 또한, 더티 리드를 유발하는 READ UNCOMMITTED는 RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로
   정합성에 문제가 많은 겨리 수준이다.
-> MySQL을 사용한다면 최소한 READ COMMITTED 이상의 격리 수준을 사용할 것을 권장한다.


Insight
- READ UNCOMMITTED 격리 수준은 더티 리트(Dirty Read) 현상을 갖고 있다. 


Application
- 트랜잭션 격리 수준 변경해보기 














```
