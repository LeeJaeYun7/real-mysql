


```

Summary
- InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에
  레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없다.
-> 일반 상용 DBMS와는 조금 다르게 InnoDB 스토리지 엔진에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는
   갭(GAP)락이 존재하는데, 그림 5.1은 InnoDB 스토리지 엔진의 레코드 락과 레코드 간의 간격을 잠그는 갭 락을 보여준다.


2) 레코드 락
- 레코드 자체만을 잠그는 것을 레코드 락(Record lock)이라고 하며,
  다른 상용 DBMS의 레코드 락과 동일한 역할을 한다.
-> 한 가지 중요한 차이는 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 것이다.
-> 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.
-> 많은 사용자가 간과하는 부분이지만, 레코드 자체를 잠그느냐 아니면 인덱스를 잠그느냐는 상당히 크고
   중요한 차이를 만들어 내기 때문에 다음에 다시 잠깐 예제로 다루겠다.

- InnoDB에서는 대부분 보조 인덱스를 이용한 변경 작업은 이어서 설명할 넥스트 키 락(Next Key lock)또는 갭 락(Gap lock)을
  사용하지만 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭(Gap, 간격)에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.


3) 갭 락
- 다른 DBMS와의 또 다른 차이가 바로 갭 락(Gap lock)이다.
-> 갭 락은 레코드 자체가 아니라 레코드의 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.
-> 갭 락의 역할을 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어하는 것이다. 

4) 넥스트 키 락
- 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락(Next Key lock)이라고 한다.
-> STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPETABLE READ 격리 수준을 사용해야 한다
-> 또한 innodb_locks_unsafe_for_binlog 시스템 변수가 비활성화되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다.
-> InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때, 소스 서버에서 만들어낸 결과와
   동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
-> 그런데 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다.
-> 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.


4) 인덱스와 잠금
- InnoDB의 잠금과 인덱스는 상당히 중요한 연관관계가 있기 때문에 다시 한 번 더 자세히 살펴보자
-> "레코드 락"을 소개하면서 잠깐 언급했듯이 InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.
-> 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다. 



```
