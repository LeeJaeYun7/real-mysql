# 배운 것

- MySQL의 DDL은 단일 스레드로 작동 → 많은 시간 소모됨

# 5 트랜잭션과 잠금

- `잠금` : 동시성을 제어하기 위한 기능. 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에 하나의 커넥션만 변경할 수 있게 해주는 역할
- `트랜잭션` : 데이터 정합성을 보장하기 위한 기능
- `격리 수준` : 하나의 트랜잭션 내에서 또는 여러 개의 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨

# 1 트랜잭션

## 1-1 트랜잭션 개념

- 쿼리가 1개든 여러 개든 상관없이 논리적인 작업 셋이 100% 적용되거나 아무것도 적용되지 않아야 함을 보장.
    - COMMIT
    - ROLLBACK
- 트랜잭션이 없다면, 여러 동작을 수행했을 때, 중간 작업이 실패 했을 경우 손수 롤백 해야하는 불편함이 있다.

## 1-2 트랜잭션의 범위는 최소화 해야!

- 커넥션 소유하는 시간 길어질 수록 여유 커넥션 수 줄어들고, 그로 인해 커넥션을 기다리는 요청이 생길 수 있다.
- 원격 서버 통신 작업은 트랜잭션 내에서 제거하는 것이 좋다!
- [ ]  아래 예제에서는 5~9번까지 트랜잭션 범위로 설정하면 좋다고 했는데, Spring MVC 구조에서는 어떻게 나눠야 할까?

### 게시물 저장 코드 예시 (개선 전)

```jsx
1. 처리 시작
		=> DB Connection 생성
    => Transaction START
2. 사용자의 로그인 여부 확인
3. 게시글 내용 오류 여부 확인
4. 첨부파일 확인 및 저장   
**5. 사용자의 게시글 내용을** DBMS **에 저장**
**6. 첨부파일 정보를 DBMS 에 저장**    
7. 저장된 내용 또는 기타 정보를 DBMS 에서 조회
8. 게시글 등록 알림 메일 발송   
**9. 알림 메일 발송 이력을 DBMS 에 저장**
    => Transaction COMMIT
    => DB Connection 반납
10 처리 완료
```

### 게시물 저장 코드 예시 (개선 후)

- 업무 요건에 따라 달라질 수 있다.

```

1. 처리 시작
2. 사용자의 로그인 여부 확인
3. 게시글 내용 오류 여부 확인
4. 첨부파일 확인 및 저장
    => DB Connection 생성
    => Transaction START
**5. 사용자의 게시글 내용을** DBMS **에 저장** -> 
**6. 첨부파일을 DBMS 에 저장**
    => Transaction COMMIT
7. 저장된 내용 또는 기타 정보를 DBMS 에서 조회 ->단순조회이므로 트랜잭션을 사용하지 않아도 무방해 보임. 
8. 게시글 등록 알림 메일 발송
    => Transaction START 
9. 알림 메일 발송 이력을 DB 에 저장 -> 작업 성격이 다르기 때문에 5,6번 트랜잭션에서 분리
    => Transaction COMMIT
    => DB Connection END
10 처리 완료
```

### MSA에서는…

- 모놀리식 서비스는 트랜잭션을 하나로 관리가 가능하지만, MSA 는 하나의 트랜잭션으로 묶기 어렵다.
- SAGA 패턴: MSA 에서의 트랜잭션을 SAGA 라는 단위로 묶는다?

---

# 2 MySQL 엔진의 잠금

> [목표] 잠금의 특징과 어떤 경우에 사용되는지 알아보기!
> 

## MySQL 잠금 구분

- **MySQL 엔진 레벨 잠금**
    - MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분
    - 엔진 레벨 잠금은 스토리지 엔진에 영향을 미친다.
- **스토리지 엔진 레벨 잠금**
    - 스토리지 엔진 간 상호 영향 미치지 않는다.

- **테이블 락** : 데이터 동기화
- **메타데이터 락** : 테이블 구조를 잠금
- **네임드 락** : 사용자 필요에 맞게 사용

## 1 글로벌 락

`FLUSH TABLES WITH READ LOCK`

- 서버 전체에 DDL, DML 대기상태
- 테이블 정보 수정 허용 x
- 일관된 백업 락
    - MySQL 8.0에서는 데이터 변경을 허용하는 백업 락 추가됨
    - 일반적인 테이블 데이터 변경 허용

## 2 테이블 락

`LOCK TABLES table_name [READ | WRITE]`

반납 : `UNLOCK TALBES`

- 명시적 락
- 묵시적 락

### 2-1 묵시적 락

- `MyISAM, MEMORY 테이블` :  데이터를 변경하는 쿼리를 실행하면 발생. 쿼리 완료되면 자동 해제
- `InnoDB 테이블` : 스토리지 엔진 차원에서 레코드 기반 잠금 제공 → 그러므로 변경 쿼리로 묵시적 테이블 락 설정되지 않는다.
    - DDL의 경우만 테이블 락이 설정

## 3 네임드 락

- `GET_LOCK()` : 임의의 “문자열”에 대한 잠금 설정
- 배치 프로그램에서 유용하게 사용 가능
    - 많은 레코드를 한꺼번에 변경하는 쿼리 → 데드락의 원인
    - 배치 프로그램과 타 프로그램을 분산해 처리 or 프로그램 코드 수정 → 현실적으로 어려움.
    - 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류하여 네임드 락을 걸고 쿼리 실행
- MySQL 8.0 부터는 네임드 락을 중첩 사용 가능
- `데드락 참고 자료` : [https://helloworld.kurly.com/blog/vsms-performance-experiment/#데드락의-원인-️](https://helloworld.kurly.com/blog/vsms-performance-experiment/#%EB%8D%B0%EB%93%9C%EB%9D%BD%EC%9D%98-%EC%9B%90%EC%9D%B8-%EF%B8%8F)

## 4 메타데이터 락

- 데이터베이스 객체의 이름이나 구조 변경 시 획득하는 잠금
- 묵시적으로 발생하는 잠금
    - `RENAME TABLE tab_a TO tab_b` : 원본이름, 변경이름 모두 잠금 설정
    - 2개의 rename 가능 : `RENAME TABLE rank TO rank_backup, rank_net to rank;`
    - 실 서비스 용일 때 “Table not found ‘rank’” 상황 발생 시키지 않을 수 있음.

### 4-1 [중요] access_log 테이블 구조 변경 예시

1. 새로운 구조 테이블 먼저 생성
2. 최근 데이터는 PK인 id값을 범위별로 나눠서 **여러 개의 스레드**로 빠르게 복사! 
    
    ```jsx
    thread1> insert into access_log_new select * from access_log where id > 0 and id < 10000;
    thread2> insert into access_log_new select * from access_log where id >10000 and id < 20000;
    thread3>
    thread4>
    ```
    
3. 남은 데이터 복사 : 나머지 데이터는 트랜잭션, 테이블 잠금 , rename table 명령으로 application 중단없이 실행 가능
    - 테이블 잠금으로 insert는 불가능.
