

```

Summary
1. 언두 로그의 데이터가 어떻게 저장되고 어떤 목적으로 사용되는지 살펴보자.
-> 언두 영역은 INSERT, UPDATE, DELETE 같은 문장으로 데이터를 변경했을 때 변경되기 전의 데이터(이전 데이터)를 보관하는 곳이다.
-> 예를 들어, 다음과 같은 문장을 실행했다고 해보자.

mysql> UPDATE member SET name='홍길동' WHERE member_id=1;

- 위 문장이 실행되면 트랜잭션을 커밋하지 않아도 실제 데이터 파일 내용은 '홍길동'으로 변경된다.
-> 그리고 변경되기 전의 값이 '벽계수'였다면, 언두 영역에는 '벽계수'라는 값이 백업되는 것이다.
-> 이 상태에서 사용자가 커밋하면 현재 상태가 그대로 유지되고, 롤백하면 언두 영역의 백업된 데이터를 다시 데이터 파일로 복구한다.


2. 언두 로그의 데이터는 크게 두 가지 용도로 사용되는데, 첫 번째 용도가 바로 위에서 언급한 트랜잭션의 롤백 대비용이다.
-> 두 번째 용도는 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공하는 데 있다.
-> 트랜잭션의 격리 수준이라는 개념이 있는데, 이는 동시에 여러 트랜잭션이 데이터를 변경하거나 조회할 때,
   한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보일지를 결정하는 기준이다.
-> 격리 수준과 언두 로그의 두 번째 사용법에 대한 자세한 설명은 5.4.3절 'REPETABLE READ'에 나온 예제를 참고하자.

3. MySQL 5.5 이전 버전의 MySQL 서버에서는 한 번 증가한 언두 로그 공간은 다시 줄어들지 않았다.
-> 예를 들어, 1억 건의 레코드가 저장된 100GB 크기의 테이블을 DELETE로 삭제한다고 가정해보자.
-> 그러면 MySQL 서버는 이 테이블에서 레코드를 한 건 삭제하고 언두 로그에 삭제되기 전 값을 저장한다.
-> 이렇게 1억 건의 레코드가 테이블에서는 삭제되지만 언두 로그로 복사돼야 한다.
-> 즉, 테이블의 크기만큼 언두 로그의 공간 사용량이 늘어나 결국 언두 로그 공간이 100GB가 되는 것이다.


4. 대용량의 데이터를 처리하는 트랜잭션뿐만 아니라 트랜잭션이 오랜시간 동안 실행될 때도 언두 로그의 양은 급격히 증가할 수 있다.
-> 트랜잭션이 완료됐다고 해서 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할 수 있는 것은 아니다.
-> 그림 4.16은 3개의 트랜잭션이 서로 시작과 종료 시점이 다르게 실행되는 것을 보여준다.
-> 그림 4.16에서 B 트랜잭션과 C 트랜잭션은 완료됐지만, 가장 먼저 시작된 트랜잭션 A는 아직 완료되지 않은 상태다.
-> 이 때, 트랜잭션 B와 C는 각각 UPDATE와 DELETE를 실행했으므로 변경 이전의 데이터를 언두 로그에 백업했을 것이다.
-> 하지만 먼저 시작된 A 트랜잭션이 아직 활성 상태이기 때문에 B와 C  트랜잭션의 완료 여부와 관계 없이 B와 C 트랜잭션이 만들어낸
   언두 로그는 삭제되지 않는다.

5. 일반적으로 응용 프로그램에서 트랜잭션 관리가 잘못된 경우 이런 현상이 발생할 수 있지만,
   사용자의 실수로 인해 더 자주 문제가 되곤 한다.
-> 서비스용으로 사용되는 MySQL 서버에서 사용자가 트랜잭션을 시작한 상태에서 완료하지 않고 하루 정도 방치했다고 가정해보자.
-> 그러면 InnoDB 스토리지 엔진은 이 트랜잭션이 시작된 시점부터 생성된 언두 로그를 계속 보존할 것이다.
-> 결국 InnoDB 스토리지 엔진의 언두 로그는 하루치 데이터 변경을 모두 저장하고,
   디스크의 언두 로그 저장 공간은 계속 증가한다.
-> 이렇게 누적된 언두 로그로 인해 디스크의 사용량이 증가하는 것은 그다지 큰 문제가 아닐 수도 있다.
-> 하지만 그동안 빈번하게 변경된 레코드를 조회하는 쿼리가 실행되면 InnoDB 스토리지 엔진은 언두 로그의 이력을 필요한만큼
   스캔해야만 필요한 레코드를 찾을 수 있기 때문에 쿼리의 성능이 전반적으로 떨어지게 된다.

6. MySQL 5.5 버전까지는 이렇게 언두 로그의 사용 공간이 한 번 늘어나면 MySQL 서버를 새로 구축하지 않는 한 줄일 수가 없었다.
-> 언두 로그가 늘어나면 디스크 사용량 뿐만 아니라 매번 백업할 때도 그만큼 더 복사를 해야 하는 문제점이 발생한다.
-> 다행스럽게도 MySQL 5.7과 MySQL 8.0으로 업그레이드 되면서 언두 로그의 공간의 문제점은 완전히 해결됐다.
-> MySQL 8.0에서는 언두 로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄이는 것도 가능하며,
   때로는 MySQL 서버가 필요한 시점에 사용 공간을 자동으로 줄여 주기도 한다.

7. 하지만 여전히 서비스 중인 MySQL 서버에서 활성 상태의 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않다.
-> 그래서 MySQL 서버의 언두 로그 레코드가 얼마나 되는지는 항상 모니터링 하는 것이 좋은데,
   다음과 같이 MySQL 서버의 언두 로그 레코드 건수를 확인할 수 있다. 


8. MySQL 서버에서 실행되는 INSERT, UPDATE, DELETE 문장이 얼마나 많은 데이터를 변경하느냐에 따라,
   평상시 언두 로그에 존재하는 레코드 건수는 상이할 수 있다.
-> 그래서 MySQL 서버별로 이 값은 차이를 보이는데, 서버별로 안정적인 시점의 언두 레코드 건수를 확인해 이를 기준으로
   언두 로그의 급증 여부를 모니터링하는 것이 좋다. 

```
![image](https://github.com/LeeJaeYun7/real-mysql/assets/134198681/7668ab4a-2e4d-450c-9186-bfbdcd1ad10d)
