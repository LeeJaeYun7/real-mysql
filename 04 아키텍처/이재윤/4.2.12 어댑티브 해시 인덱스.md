


```
Summary

1) 일반적으로 '인덱스'라고 하면 이는 테이블에 사용자가 생성해둔 B-Tree 인덱스를 의미한다.
-> 인덱스가 사용하는 알고리즘인 B-Tree는 아니더라도, 사용자가 직접 테이블에 생성해둔 인덱스가
   우리가 일반적으로 알고 있는 인덱스일 것이다.
-> 하지만 여기서 언급하는 '어댑티브 해시 인덱스'는 사용자가 수동으로 생성하는 인덱스가 아니라
   InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스이며,
   사용자는 innodb_adaptive_hash_index 시스템 변수를 이용해서 어댑티브 해시 인덱스 기능을 활성화하거나 비활성화할 수 있다.


2) B-Tree 인덱스에서 특정 값을 찾는 과정은 매우 빠르게 처리된다고 많은 사람이 생각한다.
-> 하지만 결국 빠르냐 느리냐의 기준은 상대적인 것이며, 데이터베이스 서버가 얼마나 많은 일을 하느냐에 따라
   B-Tree 인덱스에서 값을 찾는 과정이 느려질 수도 있고 빨라질 수도 있다.
-> B-Tree 인덱스에서 특정 값을 찾기 위해서는 B-Tree의 루트 노드를 거쳐서 브랜치 노드, 그리고 최종적으로 리프 노드까지 찾아가야
   원하는 레코드를 읽을 수 있다.
-> 적당한 사양의 컴퓨터에서 이런 작업을 동시에 몇 개 실행한다고 해서 성능 저하가 보이지는 않을 것이다.
-> 하지만 이런 작업을 동시에 몇 천개의 스레드로 실행하면 컴퓨터의 CPU는 엄청난 프로세스 스케줄링을 하게 되고,
   자연히 쿼리의 성능은 떨어진다.

3) 어댑티브 해시 인덱스는 이렇나 B-Tree 검색 시간을 줄여주기 위해 도입된 기능이다.
-> InnoDB 스토리지 엔진은 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고,
   필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있다.
-> B-Tree를 루트 노드부터 리프 노드까지 찾아가는 비용이 없어지고 그만큼 CPU는 적은 일을 하지만,
   쿼리의 성능은 빨라진다.
-> 그와 동시에 컴퓨터는 더 많은 쿼리를 동시에 처리할 수 있게 된다.


4) 해시 인덱스는 '인덱스 키 값'과 해당 인덱스 키 갑시 저장된 '데이터 페이지 주소'의 쌍으로 관리되는데,
   인덱스 키 값은 'B-Tree 인덱스의 고유번호(Id)와 B-Tree 인덱스의 실제 키 값'조합으로 생성된다.
-> 어댑티브 해시 인덱스의 키 값에 B-Tree 인덱스의 고윱너호가 포함되는 이유는 InnoDB 스토리지 엔진에서
   어댑티브 해시 인덱스는 하나만 존재하기 때문이다.
-> 즉, 모든 B-Tree 인덱스에 대한 어댑티브 해시 인덱스가 하나의 해시 인덱스에 저장되며,
   특정 키 값이 어느 인덱스에 속한 것인지도 구분해야 하기 때문이다.
-> 그리고 '데이터 페이지 주소'는 실제 키 값이 저장된 데이터 페이지의 메모리 주소를 가지는데,
   이는 InnoDB 버퍼 풀에 로딩된 페이지의 주소를 의미한다.
-> 그래서 어댑티브 해시 인덱스는 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리되고,
   버퍼 풀에서 해당 데이터 페이지가 없어지면, 어댑티브 해시 인덱스에서도 해당 페이지의 정보는 사라진다.


5) 어댑티브 해시 인덱스가 보여줄 수 있는 성능 효과를 그래프로 잠시 살펴보자
-> 그림 4.18과 4.19는 다음과 같이 단순한 쿼리를 MySQL 서버가 최대한 처리할 수 있는 수준까지 실행하는 상태에서
   어댑티브 해시 인덱스를 활성화했을 때의 변화를 보여준다.
-> 어댑티브 해시 인덱스가 활성화되지 않았을 때는 초당 20000개 정도의 쿼리를 처리하면서 CPU 사용률은 100%였다.
-> 그런데 어댑티브 해시 인덱스를 활성화한 후 쿼리의 처리량은 2배 가까이 늘어났음에도 불구하고,
   CPU 사용률은 오히려 떨어진 것을 볼 수 있다.
-> 물론 B-Tree의 루트 노드부터 검색이 많이 줄면서 InnoDB 내부 잠금(세마포어)의 횟수도 획기적으로 줄어든다.







```
