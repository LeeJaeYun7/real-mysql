


```

Summary

1. 리두 로그는 트랜잭션의 4가지 요소인 ACID 중에서 D(Durable)에 해당하는 영속성과 가장 밀접하게 연관돼 있다.
-> 리두 로그는 하드웨어나 소프트웨어 등 여러 가지 문제점으로 인해 MySQL 서버가 비정상적으로 종료됐을 때,
   데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치다.

2. MySQL 서버를 포함한 대부분 데이터베이스 서버는 데이터 변경 내용을 로그로 먼저 기록한다.
-> 거의 모든 DBMS에서 데이터 파일은 쓰기보다 읽기 성능을 고려한 자료 구조를 가지고 있기 때문에,
   데이터 파일 쓰기는 디스크의 랜덤 액세스가 필요하다.
-> 그래서 변경된 데이터를 데이터 파일에 기록하려면 상대적으로 큰 비용이 필요하다.
-> 이로 인한 성능 저하를 막기 위해 데이터베이스 서버는 쓰기 비용이 낮은 자료 구조를 가진 리두 로그를 가지고 있으며,
   비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 다시 서버가 종료되기 직전의 상태로 복구한다.
-> 데이터베이스 서버는 ACID도 중요하지만 성능도 중요하기 때문에 데이터 파일뿐만 아니라 리두 로그를 버퍼링할 수 있는
   InnoDB 버퍼 풀이나 리두 로그를 버퍼링할 수 있는 로그 버퍼와 같은 자료 구조도 가지고 있다. 


3. MySQL 서버가 비정상 종료되는 경우 InnoDB 스토리지 엔진의 데이터 파일은 다음과 같은 두 가지 종류의 일관되지 않은 데이터를 가질 수 있다.
-> (1) 커밋됐지만 데이터 파일에 기록되지 않은 데이터
   (2) 롤백됐지만 데이터 파일에 이미 기록된 데이터
-> 1번의 경우 리두 로그에 저장된 데이터를 데이터 파일에 다시 복사하기만 하면 된다.
-> 하지만 2번의 경우에는 리두 로그로는 해결할 수 없는데, 이때는 변경되기 전 데이터를 가진 언두 로그의 내용을 가져와
   데이터 파일에 복사하면 된다.
-> 그렇다고 해서 2번의 경우 리두 로그가 전혀 필요하지 않은 것은 아니다.
-> 최소한 그 변경이 커밋됐는지, 롤백됐는지, 아니면 트랜잭션의 실행 중간 상태였는지를 확인하기 위해서라도 리두 로그가 필요하다. 

4. 데이터베이스 서버에서 리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장한다.
   그리고 당연히 그렇게 돼야만 서버가 비정상적으로 종료됐을 때, 직전까지의 트랜잭션 커밋 내용이 리두 로그에 기록될 수 있고,
   그 리두 로그를 이용해 장애 직전 시점까지의 복구가 가능해진다.
-> 하지만 이처럼 트랜잭션이 커밋될 때마다 리두 로그를 디스크에 기록하는 작업은 많은 부하를 유발한다.
-> 그래서 InnoDB 스토리지 엔진에서 리두 로그를 어느 주기로 디스크에 동기화할지를 결정하는 innodb_flush_log_at_trx_commit 시스템 변수를 제공한다.


5. InnoDB 스토리지 엔진의 리두 로그 파일들의 전체 크기는 InnoDB 스토리지 엔진이 가지고 있는 버퍼 풀의 효율성을 결정하기 때문에 신중히 결정해야 한다.
   리두 로그 파일의 크기는 innodb_log_file_Size 시스템 변수로 결정하며, innodb_log_files_in_group 시스템 변수는 
  리두 로그 파일의 개수를 결정한다.
-> 그래서 전체 리두 로그 파일의 크기는 두 시스템 변수의 곱으로 결정된다.
-> 그리고 리두 로그 파일의 전체 크기가 InnoDB 버퍼 풀의 크기에 맞게 적절히 선택돼야 InnoDB 스토리지 엔진이 적절히 변경된 내용을 버퍼 풀에 모았다가
   한 번에 모아서 디스크에 기록할 수 있다.
-> 하지만 사용량(특히 변경 작업)이 매우 많은 DBMS 서버의 경우에는 이 리두 로그의 기록 작업이 큰 문제가 되는데,
   이러한 부분을 보완하기 위해 최대한 ACID 속성을 보장하는 수준에서 버퍼링한다.
-> 이러한 리두 로그 버퍼링에 사용되는 공간이 로그 버퍼다. 


Insight
- 리두 로그의 기능. 그리고 리두 로그가 InnoDB 버퍼 풀에서 맡는 역할 


Application
- 리두 로그 시스템 변수 튜닝해보기 


