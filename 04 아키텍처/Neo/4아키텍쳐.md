# 04. 아키텍처

# 1 MySQL 엔진 아키텍처

- 다른 DBMS와 다른 독특한 구조 : 혜택이 있지만 다른 DBMS에와 상이한 문제 발생 가능성
- MySQL 서버 = MySQL 엔진(머리 역할) + 스토리지 엔진(손발 역할)

- MySQL 엔진
    - SQL 인터페이스
    - SQL 파서
    - SQL 옵티마이저
    - 캐시 & 버퍼
- 스토리지 엔진
    - InnoDB
    - MyISAM
    - Memory
    - 성능 향상을 위해서 키 캐시(MyISAM) , 버퍼풀 (InnoDB)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4ec6301d-593e-4a80-b902-328f107b8d61/52b02221-7964-4ad5-9941-d51ae669fff2/Untitled.png)

- MySQL 엔진: 프론트, 기획자, 옵티마이제이션 및 실행계획을 세움
- 스토리지 엔진: 백엔드, 실무자, 세워진 계획을 실제로 실행
    - 스토리지 엔진에 따라 트랜잭션 처리 방법이 달라진다.
    - 스토리지 엔진에서 보는 트랜잭션과, MySQL 엔진에서 보는 테이블락은 다르다.

# 2 핸들러 API

- 핸들러(Handler) 요청: 스토리지 엔진에 쓰기 또는 읽기 요청
- 핸들러 API: MySQL 엔진과 스토리지 엔진 사이에 주고받는 API
    - 핸들러 API 통해 얼마나 많은 레코드 작업이 있었는지 아래 명령어로 확인 가능
- `SHOW GLOBAL STATUS LIKE 'Handler%'`

# 3 MySQL 스레딩 구조

- MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 작동.
    - [ ]  `내가 생각하는 이 말의 의미 :` 사용자 요청이 스레드 기반으로 작동되기 때문에 하나의 요청을 여러 개로 나눌 수 없다. 즉, 하나의 요청이 병렬 처리 되지 않는다. 이는 대량의 작업을 요청했을 때 시간이 오래걸린다는 특징이 있다.
    
- Foreground 스레드
- Background 스레드

```sql
SELECT thread_id, name, type, processlist_user, processlist_host
FROM performance_schema, threads ORDER BY type, thread_id

```

## 3.1 포그라운드 스레드(클라이언트 스레드)

클라이언트 사용자가 요청하는 쿼리 문장을 처리하는 스레드

- 기본적으론 클라이언트 당 thread. 사용자 스레드와 같은 의미
- 클라이언트 요청시 스레드가 한 개씩 물리는데, 최소 접속한 클라이언트 갯수만큼 존재
- 근데 쓰레드를 만드는 비용이 커서 `쓰레드 캐시`라는 걸로 미리 만들어놓음
- 따라서 실제 접속한 클라이언트보다 살짝 더 많은 쓰레드가 존재할 수 있음
- `thread_cache_size` 설정 : 스레드 캐시에 유지할 수 있는 최대 스레드 개수

### 쓰레드 풀과 쓰레드 캐시는 다르다!

- 쓰레드 캐시
    - 쓰레드를 미리 생성해 놓고, 연결해줌
    - 요청과 쓰레드가 1 대 1 매핑.
    - 처리 종료 시에 쓰레드 캐시에 쓰레드가 max 개수를 넘어가면 해당 쓰레드를 종료.
    쓰레드 캐시에 max 보다 작으면 반환
- 쓰레드 풀
    - 요청과 쓰레드가 1 대 1 매핑이 아니라 하나의 스레드가 여러 커넥션 요청 전담. 
    요청이 큐 자료구조로 들어감

## 3.2 백그라운드 스레드

- Insert Buffer 를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

→ MySQL엔진과 스토리지 엔진이 구분되어 있어서 나타나는 특징. 하지만 중간에 버퍼나 로그를 사용하지 않은 MyISAM은 포그라운드가 거의 모든 것 처리. 

### 쓰기 스레드

- Log thread : 로그를 디스크로 기록
- Write thread : 버퍼의 데이터를 디스크로 내려 쓰는 작업 처리.

### 스레드 수 설정

- 5.5버전부터 쓰기/읽기 스레드를 갯수를 2개 이상 지정할 수 있다.
- InnoDB에서도 읽기는 포그라운드 스레드에서 처리
    
    → 읽기는 절대 지연될 수 없으므로.  쓰기는 버퍼링되어 지연 처리 될 수 있지만
    
- 그러므로 쓰기 스레드 수를 많이 설정할 필요가 있다.
    - 특히 스토리지를 SAN, DAS사용할 경우.

# 4. 메모리 할당 및 사용 구조

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4ec6301d-593e-4a80-b902-328f107b8d61/a8a83978-2a23-4310-a425-964d50aca657/Untitled.png)

## 글로벌 메모리 영역(스레드 공유)

- 테이블 캐시
- InnoDB 버퍼 풀
- MyISAM 키 캐시
- Binary 로그 버퍼
- Redo 로그 버퍼

## 세션(커넥션) 메모리 영역(스레드 로컬 영역)

- 네트워크 버퍼(커넥션 버퍼)
- 정렬(Sort) 버퍼
- Join 버퍼
- Read 버퍼

# 5 플러그인 스토리지 엔진 모델

- 스토리지 엔진 플러그인
- 인증, 전문 검색 파서, 쿼리 재작성 플러그인
- 비밀번호 검증, 커넥션 제어 플러그인

## [중요]MySQL엔진과 스토리지 엔진의 처리 영역 구분

# 6 쿼리 실행 구조

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4ec6301d-593e-4a80-b902-328f107b8d61/606f79af-324b-4e5d-922c-739387bfce36/Untitled.png)

```
SQL 요청
-> MySQL 엔진
  -> 쿼리파서
  -> 전처리기
  -> 옵티마이저 
  -> 쿼리 실행기(group by, order by ...)  
-> 스토리지 엔진[핸들러]
  - InnoDB, MyISAM, Memory
-> SQL 결과
```

# 7 쿼리 캐시(Query Cache)

버그 투성이라서 지금은 완전히 제거됨

# 8. 스레드 풀

돈을 내야하는 엔터프라이즈 에디션에서만 지원하는 기능

### 일반적인 쓰레드 풀 구조

- 요청이 여러 개 들어올 시, 요청을 큐에 저장
- 쓰레드 풀에 있는 임의의 쓰레드가 요청을 가져와서 처리
- 쓰레드 그룹의 갯수는 실행 환경의 코어 갯수나 그 이상 만큼 설정
- 모든 쓰레드가 동작 중일 때, 새 요청에 대해서 새로운 쓰레드를 만들게 되면 스레드 풀의 의미가 없다.
    - thread_pool_stail_limit 시간 동안 기다려야 새로운 요청 처리. 그렇다고 0 에 가까운 값으로 설정하지 말자.
- 특정 트렌잭션이나 쿼리를 우선적으로 처리하는 선순위 큐와 후순위 큐

# 9. 트랜잭션 지원 메타 데이터

- 데이터 딕셔너리 = 메타데이터
    - 테이블의 구조 정보, 스토어드 프로그램 정보
    - 5.6 까지는 FRM 파일에, 8.0 부터는 InnoDB 테이블에 저장

---

# InnoDB 스토리지 엔진 아키텍처

InnoDB 가 스토리지 엔진 중 유일하게 레코드 기반의 잠금을 제공 → 높은 동시성 처리 

## 1. 프라이머리 키에 의한 클러스터링

- PK 순서대로 디스크에 저장 → PK를 이용한 RANGE 스캔 빨리 처리됨 .
- 세컨더리 인덱스 : 레코드 주소가 아닌 PK값을 논리 주소로 사용

## 2 외래 키 지원

- InnoDB 스토리지 엔진레벨에서 지원
- 다른 엔진에서는 지원하지 않음
- 실무에서 솔직히 외래키 안 쓴다!
- 레코드 적재/삭제 : `set [session/생략시(global)] foreign_key_check = off ;` 일시적 외래키 체크를 함으로써 레코드 i/d를 빠르게 수행할 수 있음.

## 3 MVCC(Multi Version Concurrency Control)

- 일반적으로 레코드 레벨 트랜잭션 지원하는 DBMS의 기능
- `잠금을 사용하지 않는 일관된 읽기를 지원`하기 위해 필요 
→ InnoDB는 Undo log 이용해 해당 기능 구현.
- InnoDB 처럼 레코드 레벨의 트랜잭션이 가능해야 지원 가능
- 그림[4-11] 102p
- 하나의 레코드에 대해서 2개의 버젼이 유지되는 것.
    - 업데이트 트랜잭션이 끝나지 않았을 때 다른 사용자는 어떤 값을 조회할까?
    - transaction isolation 에 설정된 값에 따라 어디에서 조회되는지가 다르다.
    - read-uncommited :  InnoDB 버퍼풀의 내용을 조회
    - read-commited이상(repeatable read, serializable) : 언두 영역 데이터 조회
    - rollback 했을 때 : 언두 영역의 데이터를 InnoDB버퍼풀로 복사
- 트랜잭션이 커밋되면 바로 언두 영역 데이터가 삭제되지 않고, 언두 영역을 필요로 하는 트랜잭션이 없을 때 삭제된다.

## 4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- MVCC 를 통해 지원가능

## 5 자동 데드락 감지

- 잠금 대기 목록을 Wait-for List 로 그려서 관리
- 데드락 발생시, 잠금을 일으킨 트랜잭션을 강제 종료하고 롤백함

## 6 자동화된 장애 복구

- 복구모드: innodb_force_recovery 시스템 변수 설정 후 MySQL 서버를 재시작한다.
- 복구모드 중에는 SELECT 외의 쿼리는 불가능하다.

## 7 InnoDB 버퍼 풀

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
- INSET, UPDATE, DELETE 를 모아서 한꺼번에 처리

## 8 Double Write Buffer

- Partial-page == Torn-page 문제
    - 페이지가 일부만 기록되는 현상
    - Redo 로그가 페이지 전체가 아니라 변경된 내용만 기록하기 때문에 발생
- Double-Write 를 통해 문제를 해결
    - HDD 에서는 좋지만, SSD 에서는 Double-Write 를 비활성화하는게 좋음

## 9 언두 로그(Undo Log)

- DML(INSERT, UPDATE, DELETE) 를 롤백할 수 있게 해줌
- Transaction 과 Isolation Level 에 필요

## 10 체인지 버퍼

- INSERT 와 UPDATE 변화를 체인지 버퍼 메모리에 올려두고 나중에 디스크에 반영
- 쿼리 속도를 빠르게 해줌

## 11 Redo 로그 및 로그 버퍼

- ACID 중 Durable
- 서버가 비정상적으로 종료시, 기록되지 못한 데이터를 잃지 않게 해줌
- 데이터 변경 내용을 Redo Log 로 기록해서, 변경실패시 재 요청

## 12 어댑티브 해시 인덱스

- 인덱스 == B-Tree 인덱스
- 어댑티브 해시 인덱스
    - 사용자가 만든 인덱스가 아님
    - 자주 요청되는 데이터에 대해서 InnoDB 스토리지 엔진이 자동으로 생성한 인덱스
